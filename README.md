# Hello‑World on AWS ECS Fargate — Grader‑Ready Guide

This repository delivers a **Hello‑World web service** deployed to **AWS ECS Fargate** behind an **Application Load Balancer** (ALB) using **Terraform**.  
The service responds `ok` at a public URL.

> **What you (the grader) should see**
>
> - A running ECS Fargate service in **`us‑east‑1`**.  
> - An ALB listening on **port 80**.  
> - Hitting `http://<alb_dns_name>` returns `ok`.
>
> All cloud resources live under `infra/` and are created by Terraform. Image build/push and tfvars generation are handled by the **orchestrator** in `orchestrator/`.

---

## TL;DR

```bash
# 0) Open Git Bash in the repo root and keep Docker Desktop running

# 1) One‑time AWS CLI setup (profile: arvo)
aws configure --profile arvo           # Region: us-east-1 | Output: json
aws sts get-caller-identity --profile arvo

# 2) (If needed) create venv and install orchestrator deps
py -3.13 -m venv .venv  ||  py -3.11 -m venv .venv
source .venv/Scripts/activate
pip install -r orchestrator/requirements.txt

# 3) Terraform init (local backend)
terraform -chdir=infra init -upgrade

# 4) One‑shot deploy (build+push image, write tfvars, terraform apply)
python -m orchestrator deploy \
  --repo https://github.com/Arvo-AI/hello_world \
  --app-name hello-world \
  --aws-region us-east-1 \
  --aws-profile arvo

# 5) Get the public URL
echo "http://$(terraform -chdir=infra output -raw alb_dns_name)"
```

Open the printed URL → you should see `ok`.

---

## Architecture (Terraform IaC)

**VPC:** `10.10.0.0/16`  
**Public subnets:** 2 (AZs selected dynamically)  
**Routing:** Internet Gateway + Public route table (`0.0.0.0/0`)  
**Load Balancing:** ALB + Target Group (IP mode) + Listener `:80`  
**Security Groups:**
- **ALB:** TCP/80 from `0.0.0.0/0`
- **Tasks:** TCP/**container_port** (default **8080**, can be 5000 for the sample) from ALB SG

**ECS (Fargate):**
- Cluster
- Task Definition **256 CPU / 512 MiB** with **CloudWatch Logs** to `/ecs/<app>`
- Service (default `desired_count = 1`)

**Container Registry:** ECR repo `<app>` for the built Docker image

All of the above is declared and applied by Terraform in `infra/`.

> The app container port is auto-detected by the orchestrator (Python/Flask or Node hints). You can override through `container_port` in **`infra/terraform.tfvars`**.

---

## Repository Layout

```
.
├─ orchestrator/          # Build & deploy helper (ECR + tfvars + Terraform apply)
│  ├─ __main__.py
│  └─ utils.py
├─ infra/                 # Terraform IaC (ALB + ECS + ECR + networking)
│  ├─ main.tf
│  ├─ variables.tf
│  ├─ providers.tf
│  ├─ outputs.tf
│  └─ terraform.tfvars    # auto‑generated by the orchestrator
├─ docs/
│  └─ architecture.md     # diagram & quick notes
├─ .github/workflows/
│  └─ lint-and-validate.yml  # Black + flake8 + terraform fmt/validate
├─ .flake8
├─ pyproject.toml         # Black config
├─ requirements-dev.txt   # pinned: black 24.8.0, flake8 5.0.4
├─ Makefile               # local helpers
└─ README.md
```

---

## Prerequisites

- **Windows 10/11 64‑bit**
- **Docker Desktop** with **WSL2** (Running)
- **AWS CLI v2** with an IAM user (for the demo, `AdministratorAccess`, then restrict)
- **Terraform ≥ 1.5** in PATH
- **Python ≥ 3.11** (3.13 OK) & **Git Bash**

AWS credentials are used through the named profile **`arvo`**.

---

## Deploy — detailed steps

1) **Configure the AWS CLI (one‑time)**

```bash
aws configure --profile arvo          # Region: us-east-1 | Output: json
aws sts get-caller-identity --profile arvo
```

2) **(If needed) Python environment & Terraform init**

```bash
py -3.13 -m venv .venv  ||  py -3.11 -m venv .venv
source .venv/Scripts/activate

pip install -r orchestrator/requirements.txt
terraform -chdir=infra init -upgrade
```

3) **Orchestrated build → push → apply**

```bash
python -m orchestrator deploy \
  --repo https://github.com/Arvo-AI/hello_world \
  --app-name hello-world \
  --aws-region us-east-1 \
  --aws-profile arvo
```

What the **orchestrator** does:

- Detects language/port (Python or Node heuristics).
- Writes a minimal **Dockerfile** & application stub if missing.
- Ensures the **ECR** repo exists, **builds** the image and **pushes** it.
- Generates **`infra/terraform.tfvars`** with all parameters (image URI, port, env vars).
- Runs **`terraform apply`** in `infra/`.

4) **Get the public URL**

```bash
ALB=$(terraform -chdir=infra output -raw alb_dns_name)
echo "http://$ALB" && curl -sS "http://$ALB"
```

Open the URL in your browser → **`ok`**.

---

## CloudWatch logs (optional but handy)

Gunicorn (Python) doesn’t emit access logs by default. To see `GET /` `200` entries in CloudWatch:

1. Add to **`infra/terraform.tfvars`**:

```hcl
extra_env = {
  GUNICORN_CMD_ARGS = "--access-logfile - --log-level info"
}
```

2. Re‑apply:

```bash
terraform -chdir=infra apply -auto-approve
```

3. Tail logs (Git Bash; disable path conversion for the CLI command):

```bash
MSYS_NO_PATHCONV=1 aws logs tail /ecs/hello-world --follow \
  --region us-east-1 --profile arvo
```

---

## Terraform variables (short list)

Defined in `infra/variables.tf` and set from `infra/terraform.tfvars`:

| Name            | Type          | Default | Notes                                       |
|-----------------|---------------|---------|---------------------------------------------|
| `aws_region`    | string        | —       | e.g. `us-east-1`                             |
| `app_name`      | string        | —       | also used for ECR repo and ECS names         |
| `image_uri`     | string        | —       | ECR image to run                             |
| `container_port`| number        | `8080`  | set to 5000 for the sample Flask app         |
| `desired_count` | number        | `1`     | ECS service desired tasks                    |
| `extra_env`     | map(string)   | `{}`    | additional env vars for the container        |

---

## CI / Quality gate

`.github/workflows/lint-and-validate.yml` runs on every push:

- **Black 24.8.0** (`black --check .`)
- **Flake8 5.0.4** (`flake8 orchestrator`)
- **Terraform** formatting & validation (`terraform fmt -check`, `terraform validate`)

Local equivalents:

```bash
pip install -r requirements-dev.txt
black .
flake8 orchestrator
terraform -chdir=infra fmt
terraform -chdir=infra validate
```

---

## Troubleshooting

| Symptom | Likely Cause | Fix |
|---|---|---|
| `ok` not returned | Wrong `container_port` | Set to 5000 for the sample Flask app or let the orchestrator detect the port |
| `terraform apply` fails on ECR image | Image not pushed yet | Re‑run the orchestrator or `docker push` manually |
| Tasks keep restarting | Health check/port mismatch | Confirm SG rules and the target group port match the container port |
| No logs visible | Gunicorn access logs disabled | Set `GUNICORN_CMD_ARGS="--access-logfile - --log-level info"` in `extra_env` |

---

## Clean‑up

```bash
terraform -chdir=infra destroy
# Optionally delete the ECR image/repo
```

---

## Next steps

- HTTPS via **ACM** + ALB listener `:443`
- Least‑privilege **IAM** policies
- Additional language detectors (Django, FastAPI, Node/Express, …)
- Alternative backends (Lambda, EKS) and blue/green deployments

---

**License:** MIT (unless stated otherwise).
